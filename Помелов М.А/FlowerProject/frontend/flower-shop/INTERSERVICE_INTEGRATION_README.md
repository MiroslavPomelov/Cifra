# Межсервисное взаимодействие в Flower Shop

## Обзор архитектуры

Приложение Flower Shop использует микросервисную архитектуру с несколькими backend сервисами, которые взаимодействуют между собой для обеспечения полной функциональности.

## Сервисы и их взаимодействие

### 1. Auth Service (Порт 3000)
- **Назначение**: Аутентификация и авторизация пользователей и магазинов
- **Основные функции**:
  - Регистрация и вход пользователей
  - Регистрация и вход магазинов
  - Верификация email кодов
  - Валидация JWT токенов
- **Взаимодействие**: Отправляет запросы к Users Service для создания/проверки пользователей

### 2. Users Service (Порт 3001)
- **Назначение**: Управление пользователями и их профилями
- **Основные функции**:
  - CRUD операции с пользователями
  - Управление избранными товарами
  - Хранение профилей пользователей
- **Взаимодействие**: Получает запросы от Auth Service и Frontend

### 3. Shop Service (Порт 3002)
- **Назначение**: Управление магазинами
- **Основные функции**:
  - CRUD операции с магазинами
  - Аутентификация магазинов
- **Взаимодействие**: Получает запросы от Frontend

### 4. Product Service (Порт 3003)
- **Назначение**: Управление товарами
- **Основные функции**:
  - CRUD операции с товарами
  - Поиск товаров по магазинам
  - Кэширование товаров
- **Взаимодействие**: Получает запросы от Frontend

### 5. Order Service (Порт 3004)
- **Назначение**: Управление заказами
- **Основные функции**:
  - Создание заказов
  - Обновление статусов заказов
  - История заказов пользователей
- **Взаимодействие**: Получает запросы от Frontend

### 6. Payment Service (Порт 3005)
- **Назначение**: Обработка платежей
- **Основные функции**:
  - Валидация карт
  - Обработка платежей
- **Взаимодействие**: Получает запросы от Frontend

## Frontend интеграция

### API Service
Frontend использует единый `ApiService` класс для взаимодействия со всеми сервисами:

```typescript
// Пример использования
const apiService = new ApiService();

// Получение профиля пользователя (Users Service)
const profile = await apiService.getUserProfile(userId, token);

// Создание заказа (Order Service)
const order = await apiService.createOrder(orderData, token);

// Получение товаров (Product Service)
const products = await apiService.getProducts();
```

### Приоритет API над локальными данными

**Важно**: Приложение приоритетно использует реальные данные с серверов, а не локальные данные:

1. **При загрузке профиля**: Сначала загружаются данные из JWT токена, затем обновляются через API
2. **При обновлении профиля**: Данные отправляются на сервер через API, локальное состояние обновляется только после успешного ответа
3. **При работе с заказами**: Все операции выполняются через API, localStorage используется только как кэш
4. **При работе с избранными товарами**: Все операции выполняются через API

### Fallback механизм

В случае недоступности API:
- Показывается соответствующее сообщение об ошибке
- Пользователю предлагается повторить попытку
- Локальные данные используются только как временный кэш

## Примеры межсервисного взаимодействия

### Создание заказа
1. Frontend → Order Service: Создание заказа
2. Order Service → Product Service: Проверка наличия товаров
3. Order Service → Users Service: Проверка пользователя
4. Order Service → Payment Service: Обработка платежа
5. Order Service → Frontend: Подтверждение заказа

### Получение профиля пользователя
1. Frontend → Users Service: Запрос профиля
2. Users Service → Frontend: Данные профиля
3. Frontend → Auth Service: Валидация токена (при необходимости)

## Конфигурация

### Переменные окружения
```bash
NEXT_PUBLIC_API_URL=http://localhost:80
```

### Docker Compose
Все сервисы запускаются через Docker Compose с настроенной сетью для межсервисного взаимодействия.

## Мониторинг и логирование

- Каждый сервис логирует все входящие запросы
- Frontend логирует все API вызовы и ошибки
- Используется структурированное логирование для отслеживания межсервисных вызовов

## Безопасность

- Все межсервисные вызовы защищены JWT токенами
- Используется HTTPS для production окружения
- Валидация данных на всех уровнях
- Rate limiting для предотвращения злоупотреблений

## Тестирование

Для тестирования межсервисного взаимодействия используются:
- Postman коллекции для каждого сервиса
- Интеграционные тесты
- E2E тесты для полного пользовательского сценария

## Troubleshooting

### Частые проблемы
1. **401 Unauthorized**: Проверьте JWT токен и его валидность
2. **503 Service Unavailable**: Проверьте доступность соответствующего сервиса
3. **Timeout ошибки**: Проверьте сетевые настройки между сервисами

### Логи для диагностики
- Frontend: Browser Console
- Backend: Docker logs для каждого сервиса
- Network: Browser DevTools Network tab
